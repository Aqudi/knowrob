:- module(swrl,
		[ swrl_fire/1
		, swrl_fire/2
		  %,swrl_assert/1
		]).
/** <module> Prolog-based SWRL representation.

@author Daniel BeÃŸler
*/

:- use_module(library('lang/terms/holds'),
		[ holds/3 ]).
:- use_module(library('model/OWL')).

%%
swrl_rule_hash(Rule, Hash) :-
	term_hash(Rule,X),
	atom_number(Hash,X).

%% swrl_fire(+Rule).
%
% "Fires" a rule, that is running it over the whole knowledge base
% and asserting inferred facts.
%
% @param Rule Prolog-based representation of SWRL rule.
%
swrl_fire(Rule) :-
	% generate a label for the rule from its signature
	swrl_rule_hash(Rule,Label),
	swrl_fire(Rule,Label).

%% swrl_fire(+Rule, +Label).
%
swrl_fire(Head :- Body, Label) :-
	atom_concat('swrl:', Label, Label0),
	forall(
		member(HeadAtom,Head),
		swrl_fire1(HeadAtom :- Body, Label0)
	).

%
swrl_fire1(HeadAtom :- Body, Label) :-
	swrl_vars([HeadAtom] :- Body, Vars),
	swrl_rule_pl(
		HeadAtom :- Body,
		Rule_pl, [
			var('swrl:scope',_),
			var('swrl:label',Label)|
			Vars
		]),
	Rule_pl=(?>(Impl_pl,Cond_pl)),
	findall(Fact,
		(	kb_call(Cond_pl),
			% FIXME: handle scope here, and also use scope in project below.
			%       at the moment scope is ignored! and facts will always be
			%       asserted as being universally true.
			%swrl_infer_scope(FScope),
			swrl_fact(Impl_pl, Fact)
		),
		Facts),
	kb_project(Facts).

%%
% Note: I ran into some cases where predicates
% generated by rules containing built-ins would
% not always ground the interval scope argument, resulting in an exception
% when the inferred head was asserted (see issue #285).
% The predicates below simply unify its input arg with the universal scope if needed.
swrl_infer_scope(FScope) :-
  nonvar(FScope).

swrl_infer_scope(FScope) :-
  var(FScope),
  universal_scope(FScope).

%%
swrl_fact(model_RDFS:instance_of(X,Y), has_type(X,Y)) :- !.
swrl_fact(lang_holds:holds(X,Y,Z),     holds(X,Y,Z)) :- !.

%% swrl_assert(+Rule).
%
% Assert SWRL rule in the Prolog KB.
%
% @param Rule Prolog-based representation of SWRL rule.
%
swrl_assert(Rule) :-
	% generate a label for the rule from its signature
	swrl_rule_hash(Rule,Label),
	swrl_assert(Rule,Label).

%%
swrl_assert(Head :- Body, Label) :-
	atom_concat('swrl:', Label, Label0),
	forall(
		member(HeadAtom,Head),
		swrl_assert1(HeadAtom :- Body, Label0)
	).

%
swrl_assert1(HeadAtom :- Body, Label) :-
	swrl_vars([HeadAtom] :- Body, Vars),
	swrl_rule_pl(
		HeadAtom :- Body,
		Rule_pl, [
			var('swrl:scope',_),
			var('swrl:label',Label)|
			Vars
		]),
	% FIXME: handle scope here
	% TODO need to support facts??
	Rule_pl=(?>(Impl_pl,Cond_pl)),
	comma_list(Cond_pl0,Cond_pl),
	% expand into regular Prolog rule
	% NOTE: this also calls query_assert/1
	expand_term(?>(Impl_pl,Cond_pl0), Expanded),
	% finally assert another clause of instance_of or holds
	assertz(Expanded).
  
swrl_rule_pl_implication(Implication :- _, Implication) :- !.
swrl_rule_pl_implication(Implication, Implication).

%% swrl_rule_pl
swrl_rule_pl(Fact :- [], Fact_pl, Vars) :-
	!, swrl_implication_pl(Fact, Fact_pl, Vars).

swrl_rule_pl(
		class(Cls,S)                      :- Cond,
		model_RDFS:instance_of(S_var,Cls) ?> Cond_pl,
		Vars) :-
	swrl_var(Vars, S, S_var),
	swrl_condition_pl(Cond, Cond_pl, Vars),!.

swrl_rule_pl(
		property(S,P,O)                 :- Cond,
		lang_holds:holds(S_var,P,O_var) ?> Cond_pl,
		Vars) :-
	swrl_var(Vars, S, S_var),
	swrl_var(Vars, O, O_var),
	swrl_condition_pl(Cond, Cond_pl, Vars),!.
  
%% swrl_condition_pl
swrl_condition_pl([], [], _) :- !.

swrl_condition_pl([X|Xs], [Y|Ys], Vars) :-
	swrl_condition_pl(X, Y, Vars),
	swrl_condition_pl(Xs, Ys, Vars).
  
swrl_condition_pl(
		class(Cls,S),
		instance_of_description(S_var,Cls),
		Vars) :-
	compound(Cls),!,
	swrl_var(Vars, S, S_var).

swrl_condition_pl(
		class(Cls,S),
		instance_of(S_var,Cls),
		Vars) :-
	swrl_var(Vars, S, S_var).

swrl_condition_pl(
		property(S,P,O),
		holds(S_var,P,O_var),
		Vars) :-
	swrl_var(Vars, S, S_var),
	swrl_var(Vars, O, O_var).

swrl_condition_pl(Builtin, Builtin_pl, Vars) :-
	compound(Builtin),
	Builtin =.. [Functor|Args],
	swrl_builtin_pl(Functor, Args, Builtin_pl, Vars).

%% swrl_builtin_pl
% TODO (DB): support more builtins: matches, listConcat, member, length, ...
%
swrl_builtin_pl(
		equal, [S,O],
		(S_var == O_var),
		Vars) :-
	swrl_var(Vars, S, S_var),
	swrl_var(Vars, O, O_var).

swrl_builtin_pl(
		notEqual, [S,O],
		(S_var \== O_var),
		Vars) :-
	swrl_var(Vars, S, S_var),
	swrl_var(Vars, O, O_var).

swrl_builtin_pl(
		lessThan, [A,B],
		(A_num < B_num),
		Vars) :-
	swrl_nums([A,B], [A_num,B_num], Vars).

swrl_builtin_pl(
		lessThanOrEqual, [A,B],
		(A_num =< B_num),
		Vars) :-
	swrl_nums([A,B], [A_num,B_num], Vars).

swrl_builtin_pl(
		greaterThan, [A,B],
		(A_num > B_num),
		Vars) :-
	swrl_nums([A,B], [A_num,B_num], Vars).

swrl_builtin_pl(
		greaterThanOrEqual, [A,B],
		(A_num >= B_num),
		Vars) :-
	swrl_nums([A,B], [A_num,B_num], Vars).

%% math builtins
swrl_builtin_pl(
		add, [A,B,C],
		(A_num is B_num + C_num),
		Vars) :-
	swrl_nums([A,B,C], [A_num,B_num,C_num], Vars).

swrl_builtin_pl(
		subtract, [A,B,C],
		(A_num is B_num - C_num),
		Vars) :-
	swrl_nums([A,B,C], [A_num,B_num,C_num], Vars).

swrl_builtin_pl(
		multiply, [A,B,C],
		(A_num is B_num * C_num),
		Vars) :-
  swrl_nums([A,B,C], [A_num,B_num,C_num], Vars).

swrl_builtin_pl(
		divide, [A,B,C],
		(A_num is B_num / C_num),
		Vars) :-
  swrl_nums([A,B,C], [A_num,B_num,C_num], Vars).

swrl_builtin_pl(
		mod, [A,B,C],
		(A_num is B_num mod C_num),
		Vars) :-
  swrl_nums([A,B,C], [A_num,B_num,C_num], Vars).

swrl_builtin_pl(
		pow, [A,B,C],
		(A_num is B_num ** C_num),
		Vars) :-
  swrl_nums([A,B,C], [A_num,B_num,C_num], Vars).

swrl_builtin_pl(
		abs, [A,B],
		(A_num is abs(B_num)),
		Vars) :-
  swrl_nums([A,B], [A_num,B_num], Vars).

%% boolean builtins
swrl_builtin_pl(booleanNot, [S], not(S_var), Vars) :-
  swrl_var(Vars, S, S_var).

%% string builtins
swrl_builtin_pl(
		stringConcat, [A,B,C],
		atom_concat(C_atom,A_atom,B_atom),
		Vars) :-
  swrl_atoms([A,B,C], [A_atom,B_atom,C_atom], Vars).

swrl_builtin_pl(
		stringLength, [A,L],
		atom_length(A_atom, L_num),
		Vars) :-
  swrl_atom(A,A_atom,Vars),
  swrl_atom_number(L,L_num,Vars).

swrl_builtin_pl(
		upperCase, [A,Upper],
		upcase_atom(A_atom, Upper_atom),
		Vars) :-
  swrl_atoms([A,Upper], [A_atom,Upper_atom], Vars).

swrl_builtin_pl(
		lowerCase, [A,Lower],
		downcase_atom(A_atom, Lower_atom),
		Vars) :-
  swrl_atoms([A,Lower], [A_atom,Lower_atom], Vars).

swrl_builtin_pl(
		contains, [A,X],
		sub_atom(A_atom, _, _, _, X_atom),
		Vars) :-
  swrl_atoms([A,X], [A_atom,X_atom], Vars).

swrl_builtin_pl(
		startsWith, [A,X],
		atom_prefix(A_atom, X_atom),
		Vars) :-
  swrl_atoms([A,X], [A_atom,X_atom], Vars).

swrl_builtin_pl(
		endsWith, [A,X],
		atom_concat(_, X_atom, A_atom),
		Vars) :-
  swrl_atoms([A,X], [A_atom,X_atom], Vars).

%% extensions
% Note: built-in arguments are passed individually as at the moment
% the parser does not support argument lists.
%
swrl_builtin_pl(
		makeOWLIndividual, [A|Args],
		make_owl_individual(A_atom, [Label|Pattern]), Vars) :-
	memberchk(var('swrl:label',Label), Vars),
	swrl_atoms([A|Args], [A_atom|Pattern], Vars).


%% Find all the variables in a SWRL rule and map those to anonymous
%% Prolog variables for later unification.
swrl_vars(Head :- Body, Variables) :-
	findall(VarName,
		(	(member(Atom,Head) ; member(Atom,Body)),
			swrl_var_names(Atom,VarName)
		),
		VarNames),
	list_to_set(VarNames, VarNamesUnique),
	maplist(swrl_var_pl(_), VarNamesUnique,Variables).
swrl_var_pl(_,Y,var(Y,_)).

%% Find variables in a SWRL atom
swrl_var_names(var(Var), Var) :- atom(Var), !.
swrl_var_names(Term, Var) :-
	compound(Term), !,
	Term =.. [_|Args],
	member(Arg, Args),
	swrl_var_names(Arg, Var).

%% Map between name of a SWRL variable and the corresponding
%% Prolog variable.
swrl_var(Vars, var(X), PrologVar) :-
	!, swrl_var(Vars, X, PrologVar).
swrl_var([var(Name,PrologVar)|_], Name, PrologVar) :- !.
swrl_var([_|Rest], Name, PrologVar) :-
	swrl_var(Rest, Name, PrologVar).
swrl_var([], Constant, Typed) :-
	mng_client:mng_strip_type(Constant,Type,X),
	mng_client:mng_strip_type(Typed,Type,X).

%%
swrl_atom(A, B, _) :-
	var(A),!, B=A.
swrl_atom(var(A), A_val, Vars) :-
	swrl_var(Vars, A, A_var),
	swrl_atom(A_var,A_val,Vars).
swrl_atom(Atom, Atom, _) :-
	atom(Atom).
swrl_atoms([], [], _).
swrl_atoms([X|Xs], [Y|Ys], Vars) :-
	swrl_atom(X,Y,Vars),
	swrl_atoms(Xs,Ys,Vars).

%%
swrl_atom_number(var(A), A_num, Vars) :-
	!, swrl_var(Vars, A, A_var),
	(	ground(A_var)
	->	swrl_atom_number(A_var, A_num, Vars)
	;	A_num = A_var
	).

swrl_atom_number(A, A_num, _) :-
	atom(A), !,
	catch(atom_number(A,A_num), _, fail).

swrl_atom_number(A_num, A_num, _) :-
	number(A_num), !.

%%
swrl_nums([],[],_).
swrl_nums([X|Xs],[Y|Ys],Vars) :-
	swrl_atom_number(X,Y,Vars),
	swrl_nums(Xs,Ys,Vars).

% add a database predicate that stores a mapping between
% individual IRI and a SWRL pattern of the rule that has
% generated the individual.
:- mongolog_add_predicate(has_individual_pattern,
		[individual,pattern], [[pattern]]).

%
make_owl_individual1(Individual, Pattern, Type) ?>
	% generate a unique IRI, use Type as prefix
	new_iri(Individual,Type),
	% assert facts about the new individual
	project(is_individual(Individual)),
	project(has_type(Individual,Type)),
	% assert mapping between pattern and individual
	assert(has_individual_pattern(Individual, Pattern)).

%%
%
% If the first argument is already bound when make_individual/3 is called,
% this method returns true and no individual is created
%
make_owl_individual(Individual, Pattern, Type) ?>
	ground(Pattern),
	atomic_list_concat(Pattern, '::', PatternAtom),
	once((
		% succeed if individual is an atom already
		atom(Individual)
		% find existing individual given the pattern
	;	(var(Individual), has_individual_pattern(Individual, PatternAtom))
		% else create a new individual
	;	(var(Individual), make_owl_individual1(Individual, PatternAtom, Type))
	)).

%%
%
make_owl_individual(Individual, Pattern) ?>
	make_owl_individual(Individual, Pattern, owl:'Thing').
